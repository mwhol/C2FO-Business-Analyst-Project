/*
Using SQLite3
*/


--A BIT OF BASIC DATA EXPLORATION
SELECT `SHIP MODE`, COUNT(`SHIP MODE`) FROM ORDERS GROUP BY `SHIP MODE`;
SELECT `CUSTOMER NAME`, COUNT(`CUSTOMER NAME`) FROM ORDERS GROUP BY `CUSTOMER NAME` ORDER BY COUNT(`CUSTOMER NAME`) DESC LIMIT 5;
SELECT SEGMENT, CATEGORY, COUNT(), AVG(PROFIT) FROM ORDERS GROUP BY SEGMENT, CATEGORY ORDER BY AVG(PROFIT) DESC;
SELECT `ORDER ID`, DISCOUNT, CATEGORY, SEGMENT, PROFIT FROM ORDERS WHERE PROFIT<0 ORDER BY PROFIT ASC;

SELECT * FROM PEOPLE;
--LETS FILL OUT THE PEOPLE TABLE WITH THE INFO FROM ORDERS
BEGIN;
INSERT INTO PEOPLE (PERSON, REGION) SELECT DISTINCT ORDERS.`CUSTOMER NAME`, ORDERS.REGION FROM ORDERS;
SELECT * FROM PEOPLE ORDER BY PERSON DESC LIMIT 50;
--WAIT THAT DOESN'T LOOK RIGHT, SEEMS PEOPLE ARE ASSOCIATED WITH MANY REGIONS
ROLLBACK;

--LET'S MAKE THE PEOPLE TABLE A BIT MORE USEFUL TO US
--BEGIN;
--Sqlite doesn't support Alter Table Drop Column like other SQL Dialects
--ALTER TABLE PEOPLE DROP COLUMN REGION;
ALTER TABLE PEOPLE ADD CustomerID TEXT;
ALTER TABLE PEOPLE ADD Segment TEXT;
ALTER TABLE PEOPLE ADD Order_Count INTEGER;
ALTER TABLE PEOPLE ADD AVG_PROFIT REAL;
DELETE FROM PEOPLE;


INSERT INTO PEOPLE (PERSON, CustomerID, SEGMENT, ORDER_COUNT, AVG_PROFIT)
SELECT `CUSTOMER NAME`, `CUSTOMER ID`, SEGMENT, COUNT(), AVG(PROFIT) 
FROM ORDERS GROUP BY `CUSTOMER NAME`;


ALTER TABLE PEOPLE ADD ReturnCount INTEGER;

--BIG FINALE, SLOW UPDATE BUT DEMONSTRATION OF HEAVILY NESTED LOGIC
UPDATE People
SET ReturnCount = (
SELECT CountedReturns FROM (
SELECT *, COUNT() AS CountedReturns FROM ORDERS LEFT OUTER JOIN RETURNS 
ON ORDERS.`ORDER ID`=RETURNS.`ORDER ID` 
WHERE RETURNED='Yes' GROUP BY `CUSTOMER NAME`
)
WHERE `Customer ID`=People.`CUSTOMERID`);

UPDATE PEOPLE
SET ReturnCount=0
WHERE ReturnCount IS NULL;